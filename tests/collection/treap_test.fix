module TreapTest;

import Minilib.Collection.Treap;
import Minilib.Collection.Trait.Set;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
import Minilib.Testing.TestUtilArray;

import AbstractSetTests;

test_simple: TestCase;
test_simple = (
    make_test("test_simple") $ |_|
    let n = 30;
    let shuffled = Array::from_map(n, |i| (i * 1234567) % n);
    //println("shuffled=" + shuffled.to_string).lift;;
    let t: Treap (KeyLessThan I64) I64 = Treap::empty;
    let t = shuffled.to_iter.fold(t, insert);
    let sorted = t.to_array;
    //println("sorted=" + sorted.to_string).lift;;
    //println(t._debug_to_string).lift;;
    assert_equal("eq", shuffled.sort, sorted);;
    pure()
);


type IgnoreCase = unbox struct {};

impl IgnoreCase: KeyCompare {
    type Key IgnoreCase = String;
    empty = IgnoreCase {};
    compare = |x, y, kc| x.to_lower < y.to_lower;
}

type WithFunc k = unbox struct { func: k -> k -> Bool };

impl WithFunc k: KeyCompare {
    type Key (WithFunc k) = k;
    empty = WithFunc { func: |_, _| false };    // dummy
    compare = |x, y, kc| (kc.@func)(x, y);
}

test_kc: TestCase;
test_kc = (
    make_test("test_kc") $ |_|
    let n = 5;
    let t: Treap (KeyLessThan I64) I64 = range(0, n).fold(Treap::empty, insert);
    assert_equal("eq", [0, 1, 2, 3, 4], t.to_array);;
    let t: Treap (KeyGreaterThan I64) I64 = range(0, n).fold(Treap::empty, insert);
    assert_equal("eq", [4, 3, 2, 1, 0], t.to_array);;
    let t: Treap (WithValue String (KeyGreaterThan I64)) (I64, String) = range(0, n).map(|i| (i, (n-i).to_string)).fold(Treap::empty, insert);
    assert_equal("eq", [(4,"1"), (3,"2"), (2,"3"), (1,"4"), (0,"5")], t.to_array);;
    let arr = ["Hello", "World", "Foo bar baz", "helllooo", "woooorld"];
    let t: Treap (IgnoreCase) String = arr.to_iter.fold(Treap::empty, insert);
    assert_equal("eq", ["Foo bar baz", "helllooo", "Hello", "woooorld", "World"], t.to_array);;
    let kc: WithFunc I64 = WithFunc{ func: less_than };
    let t: Treap (WithFunc I64) I64 = range(0, n).fold(Treap::make(kc), insert);
    assert_equal("eq", [0, 1, 2, 3, 4], t.to_array);;
    pure()
);

test_perf: TestCase;
test_perf = (
    make_test("test_perf") $ |_|
    let n = 1000000;
    //let n = 100000;
    println("test_perf (n=" + n.to_string + ")").lift;;
    let array = Iterator::range(0, n).to_array;
    let shuffled = array.reorder(shuffle(5432));
    let (tree, from_iter_time) = *consumed_time_while_io(do {
        pure();;
        pure $ shuffled.to_iter.Treap::from_iter
    }).lift;
    println(" from_iter: " + from_iter_time.to_string + " seconds").lift;;
    assert_equal("size", n, tree.get_size);;
    /*
    let (ans1, ans1_time) = *consumed_time_while_io(do {
        pure();;
        pure $ tree.to_iter.to_array
    }).lift;
    println(" to_iter.to_array: " + ans1_time.to_string + " seconds").lift;;
    assert_equal("eq", ans1, array);;
    */
    let (ans2, ans2_time) = *consumed_time_while_io(do {
        pure();;
        pure $ tree.to_array
    }).lift;
    println(" to_array: " + ans2_time.to_string + " seconds").lift;;
    assert_equal("eq", ans2, array);;
    let (tree, erase_time) = *consumed_time_while_io(do {
        pure();;
        pure $ shuffled.to_iter.fold(
            tree, |x| erase(x)
        )
    }).lift;
    println(" erase: " + erase_time.to_string + " seconds").lift;;
    assert_equal("size", 0, tree.get_size);;
    pure()
);

main: IO ();
main = (
    let empty_set = Treap::empty: Treap (KeyLessThan I64) I64;
    [
        AbstractSetTests::abstract_set_tests(empty_set),
        test_simple,
        test_kc,
        //test_perf,
        TestCase::empty
    ]
    .run_test_driver
);
