// Tests for Minilib.Collection.Trait::SortedSet
module SortedSetTests;

import Minilib.Collection.Trait;
import Minilib.Testing.TestUtilArray;
import Minilib.Testing.UnitTest;

test_select_range:
    [set: SortedSet, SetElem set = I64, SetIterator set = iter, iter: Iterator, Item iter = I64]
    set ->  TestCase;
test_select_range = |empty_set| (
    let keys_sorted = Iterator::range(0, 30).to_array;
    let keys_shuffled = keys_sorted.reorder(shuffle(345));
    let set = keys_shuffled.to_iter.fold(
        empty_set, |x, set|
        set.insert(x)
    );
    make_table_test("test_select_range",
        [
            (included(3), excluded(6), [3, 4, 5]),
            (excluded(3), included(6), [4, 5, 6]),
            (included(5), excluded(6), [5]),
            (included(5), included(5), [5]),
            (included(5), excluded(5), []),
            (included(-1), excluded(1), [0]),
            (excluded(28), excluded(31), [29]),
            (excluded(10), excluded(14), [11, 12, 13]),
            (included(28), unbound(), [28, 29]),
            (unbound(), excluded(2), [0, 1]),
            (unbound(), unbound(), keys_sorted),
        ],
        |(begin, end, expected)|
        let actual = set.select_range(begin, end, true).Iterator::to_array;
        assert_equal("ascending", expected, actual);;
        let actual = set.select_range(begin, end, false).Iterator::to_array;
        assert_equal("descending", expected.reverse, actual);;
        pure()
    )
);

sorted_set_tests:
    [set: SortedSet, SetElem set = I64, SetIterator set = iter, iter: Iterator, Item iter = I64]
    set -> TestCase;
sorted_set_tests = |empty_set| (
    [
        test_select_range(empty_set),
    ]
    .run_tests
);
