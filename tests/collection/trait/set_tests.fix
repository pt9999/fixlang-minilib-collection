
// Tests for Minilib.Collection.Trait::Set
module SetTests;

import Random;
import Minilib.Collection.Trait;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
import Minilib.Testing.TestUtilArray;
import Minilib.Trait.Traversable;

test_is_empty:
    [set: Set, SetElem set = I64]
    set ->  TestCase;
test_is_empty = |empty_set| (
    make_test("test_is_empty") $ |_|
    let set = empty_set;
    assert_true("empty", set.is_empty);;
    let set = set.insert(1);
    assert_false("not empty", set.is_empty)
);

test_get_size:
    [set: Set, SetElem set = I64]
    set ->  TestCase;
test_get_size = |empty_set| (
    make_test("test_get_size") $ |_|
    let set = empty_set;
    assert_equal("0", 0, set.get_size);;
    let set = set.insert(1);
    assert_equal("1", 1, set.get_size)
);

test_contains:
    [set: Set, SetElem set = I64]
    set ->  TestCase;
test_contains = |empty_set| (
    make_test("test_contains") $ |_|
    let set = empty_set;
    assert_false("not contains", set.contains(1));;
    let set = set.insert(1);
    assert_true("contains", set.contains(1));;
    assert_false("not contains 2", set.contains(2))
);

test_insert:
    [set: Set, SetElem set = I64]
    set ->  TestCase;
test_insert = |empty_set| (
    make_test("test_insert") $ |_|
    let set = empty_set;
    let set = set.insert(42);
    let set = set.insert(42);
    assert_equal("1", 1, set.get_size);;
    let set = set.insert(43);
    let set = set.insert(43);
    let set = set.insert(42);
    assert_equal("2", 2, set.get_size)
);

test_erase:
    [set: Set, SetElem set = I64]
    set ->  TestCase;
test_erase = |empty_set| (
    make_test("test_erase") $ |_|
    let set = empty_set;
    let set = set.erase(42);
    assert_equal("0", 0, set.get_size);;
    let set = set.insert(42);
    let set = set.insert(42);
    assert_equal("1", 1, set.get_size);;
    let set = set.erase(42);
    assert_equal("0", 0, set.get_size)
);

test_intersect:
    [set: Set, SetElem set = I64]
    set ->  TestCase;
test_intersect = |empty_set| (
    make_table_test("test_intersect",
        [
            ([], [], []),
            ([], [1], []),
            ([1], [], []),
            ([1], [1], [1]),
            ([1, 2], [1], [1]),
            ([1], [1, 2], [1]),
            ([1, 2], [1, 2], [1, 2]),
            ([1, 2], [1, 3], [1]),
        ],
        |(arr1, arr2, expected)|
        let set1 = arr1.to_iter.fold(empty_set, insert);
        let set2 = arr2.to_iter.fold(empty_set, insert);
        let set3 = set1.intersect(set2);
        let actual = set3.to_array;
        assert_equal("eq", expected, actual)
    )
);

test_merge:
    [set: Set, SetElem set = I64]
    set ->  TestCase;
test_merge = |empty_set| (
    make_table_test("test_merge",
        [
            ([], [], []),
            ([], [1], [1]),
            ([1], [], [1]),
            ([1], [1], [1]),
            ([1, 2], [1], [1, 2]),
            ([1], [1, 2], [1, 2]),
            ([1, 2], [1, 2], [1, 2]),
            ([1, 2], [1, 3], [1, 2, 3]),
        ],
        |(arr1, arr2, expected)|
        let set1 = arr1.to_iter.fold(empty_set, insert);
        let set2 = arr2.to_iter.fold(empty_set, insert);
        let set3 = set1.merge(set2);
        let actual = set3.to_array;
        assert_equal("eq", expected, actual)
    )
);

test_to_iter:
    [set: Set, SetElem set = I64, SetIterator set = iter, iter: Iterator, Item iter = I64]
    set ->  TestCase;
test_to_iter = |empty_set| (
    make_test("test_to_iter") $ |_|
    let iter = Iterator::range(0, 10);
    let set = iter.fold(empty_set, insert);
    assert_equal("eq", iter.to_array, set.to_iter.to_array);;
    pure()
);

test_to_array:
    [set: Set, SetElem set = I64]
    set ->  TestCase;
test_to_array = |empty_set| (
    make_test("test_to_array") $ |_|
    let iter = Iterator::range(0, 10);
    let set = iter.fold(empty_set, insert);
    assert_equal("eq", iter.to_array, set.to_array);;
    pure()
);

test_insert_erase_ok:
    [set: Set, SetElem set = I64]
    set -> (I64, Reorder, Reorder) -> TestCase;
test_insert_erase_ok = |empty_set, (n, insert_reorder, erase_reorder)| (
    let testname = "test_insert_erase_ok("+ n.to_string + "," +
                    insert_reorder.to_string + "," +
                    erase_reorder.to_string + ")";
    make_test(testname) $ |_|
    let keys_sorted = Iterator::range(0, n).to_array;

    // insert with keys shuffled
    let keys_shuffled = keys_sorted.reorder(insert_reorder);
    let set = empty_set;
    let set = keys_shuffled.to_iter.fold(
        set, |k, set|
        set.insert(k)
    );

    // assert that the size is same as keys
    assert_equal("size after insertion", keys_sorted.get_size, set.get_size);;

    // assert that keys are sorted
    let keys_current = set.to_array;
    assert_equal("keys are sorted", keys_sorted, keys_current);;

    // assert that keys exist
    keys_sorted.to_iter.foreach_m(|k|
        assert_equal("set.contains", true, set.contains(k))
    );;

    // erase keys
    let keys_shuffled = keys_sorted.reorder(erase_reorder);
    let set = keys_shuffled.to_iter.fold(
        set, |i, set|
        set.erase(i)
    );
    let keys_current = set.to_array;
    assert_equal("[] == keys_current", [], keys_current);;
    assert_true("set.is_empty", set.is_empty);;
    assert_equal("size after erase", 0, set.get_size);;

    pure()      // success
);

test_insert_erase_batch:
    [set: Set, SetElem set = I64]
    set -> TestCase;
test_insert_erase_batch = |empty_set| (
    do {
        let n = 30;
        let insert_reorder = *[skip(15), ascending(), descending(), shuffle(123)];
        let erase_reorder = *[skip(15), ascending(), descending(), shuffle(345)];
        pure $ empty_set.test_insert_erase_ok $ (n, insert_reorder, erase_reorder)
    }.run_tests
);

test_intersect_merge_batch:
    [set: Set, SetElem set = I64]
    set -> TestCase;
test_intersect_merge_batch = |empty_set| (
    make_table_test(
        "test_intersect_merge_batch",
        [
            (3456, 100, 300),
            (3456, 100, 200),
            (3457, 100, 100),
            (3458, 100, 50),
        ],
        |(seed, n, modulo)|
        let random = Random::init_by_seed(seed.to_U64);
        let (random, arr1) = random.generate_array(n, generate_I64_nonneg);
        let (random, arr2) = random.generate_array(n, generate_I64_nonneg);
        let arr1 = arr1.map(|x| x % modulo);
        let arr2 = arr2.map(|x| x % modulo);
        let set1 = arr1.to_iter.fold(empty_set, insert);
        let set2 = arr2.to_iter.fold(empty_set, insert);
        // test for intersection
        let set3 = set1.intersect(set2);
        let actual = set3.to_array;
        let expected = (
            let arr1 = arr1.sort.dedup;
            let arr2 = arr2.sort.dedup;
            arr1.to_iter.filter(|x| arr2.find_by(eq(x)).is_some).to_array
        );
        //eval debug_eprintln("intersect");
        //eval debug_eprintln(" expected=" + expected.to_string);
        //eval debug_eprintln(" actual  =" + actual.to_string);
        assert_equal("intersect", expected, actual);;
        // test for merge
        let set4 = set1.merge(set2);
        let actual = set4.to_array;
        let expected = (arr1 + arr2).sort.dedup;
        //eval debug_eprintln("merge");
        //eval debug_eprintln(" expected=" + expected.to_string);
        //eval debug_eprintln(" actual  =" + actual.to_string);
        assert_equal("merge", expected, actual);;
        pure()
    )
);

test_get_size_batch:
    [set: Set, SetElem set = I64]
    set -> TestCase;
test_get_size_batch = |empty_set| (
    make_table_test(
        "test_get_size_batch",
        [
            (1234, 100, 2),
            (1235, 100, 10),
            (1236, 10, 2),
            (1237, 10, 10),
        ],
        |(seed, n, max_op)|
        let debug_eprintln = if false { debug_eprintln } else { |_| () };
        eval debug_eprintln ("--- test_get_size_batch (seed, n, max_op)=" + (seed, n, max_op).to_string);
        let random = Random::init_by_seed(seed.to_U64);
        let mask = Array::fill(n, false);
        let size = 0;
        let set = empty_set;
        loop_m(
            (random, mask, size, set, 0), |(random, mask, size, set, i)|
            if i >= n * 10 { break_m $ () };
            let (random, v) = random.generate_U64;
            let (random, op) = random.generate_U64;
            let v = (v % n.to_U64).to_I64;
            let op = (op % max_op.to_U64).to_I64;
            if op == 0 {
                let size = if mask.@(v) { size } else { size + 1 };
                let mask = mask.Array::set(v, true);
                let set = set.insert(v);
                eval debug_eprintln("insert " + (v, size).to_string);
                assert_equal("insert", size, set.get_size);;
                //assert_equal("insert root get_size", set.@root.get_size, set.get_size);;
                assert_true("contains", set.contains(v));;
                assert_equal("to_array", range(0,n).filter(|i| mask.@(i)).to_array, set.to_array);;
                continue_m $ (random, mask, size, set, i + 1)
            } else { // op == 1 or above
                let size = if !mask.@(v) { size } else { size - 1 };
                let mask = mask.Array::set(v, false);
                let set = set.erase(v);
                eval debug_eprintln("erase " + (v, size).to_string);
                assert_equal("erase", size, set.get_size);;
                //assert_equal("erase root get_size", set.@root.get_size, set.get_size);;
                assert_false("not contains", set.contains(v));;
                assert_equal("to_array", range(0,n).filter(|i| mask.@(i)).to_array, set.to_array);;
                continue_m $ (random, mask, size, set, i + 1)
            }
        )
    )
);

test_large_elements_batch:
    [set: Set, SetElem set = I64]
    set -> TestCase;
test_large_elements_batch = |empty_set| (
    make_table_test(
        "test_large_elements_batch",
        [
            (12347, 100),
            (12348, 200),
        ],
        |(seed, n)|
        let random = Random::init_by_seed(seed.to_U64);
        let (random, elements) = random.generate_array(n, generate_U64 >> Functor::map(to_I64));
        let elements_sorted = elements.sort.dedup;
        let elements_shuffled =  elements_sorted.reorder(shuffle(seed * 10 + 1));
        let set = elements_shuffled.to_iter.fold(
            empty_set, |element, set|
            set.insert(element)
        );
        let expected = elements_sorted;
        let actual = set.to_array;
        assert_equal("eq", expected, actual)
    )
);

// `test_perf` for the abstract type is a little slower than `test_perf` for the concrete type. why?

test_perf:
    [set: Set, SetElem set = I64, SetIterator set = iter, iter: Iterator, Item iter = I64]
    set -> I64 -> TestCase;
test_perf = |empty_set, n| (
    make_test("test_perf") $ |_|
    //let n = 1000000;
    println("test_perf (n=" + n.to_string + ")").lift;;
    let array = Iterator::range(0, n).to_array;
    let shuffled = array.reorder(shuffle(5432));
    let (set, insert_time) = *consumed_time_while_io(do {
        pure();;
        pure $ shuffled.to_iter.fold(empty_set, insert)
    }).lift;
    println(" insert: " + insert_time.to_string + " seconds").lift;;
    assert_equal("size", n, set.get_size);;
    let (ans1, ans1_time) = *consumed_time_while_io(do {
        pure();;
        pure $ set.to_iter.Iterator::to_array
    }).lift;
    println(" to_iter.to_array: " + ans1_time.to_string + " seconds").lift;;
    assert_equal("eq", ans1, array);;
    let (ans2, ans2_time) = *consumed_time_while_io(do {
        pure();;
        pure $ set.to_array
    }).lift;
    println(" to_array: " + ans2_time.to_string + " seconds").lift;;
    assert_equal("eq", ans2, array);;
    let (set, erase_time) = *consumed_time_while_io(do {
        pure();;
        pure $ shuffled.to_iter.fold(
            set, |x| erase(x)
        )
    }).lift;
    println(" erase: " + erase_time.to_string + " seconds").lift;;
    assert_equal("size", 0, set.get_size);;
    pure()
);

set_tests:
    [set: Set, SetElem set = I64, SetIterator set = iter, iter: Iterator, Item iter = I64]
    set -> TestCase;
set_tests = |empty_set| (
    [
        test_is_empty(empty_set),
        test_get_size(empty_set),
        test_contains(empty_set),
        test_insert(empty_set),
        test_erase(empty_set),
        test_intersect(empty_set),
        test_merge(empty_set),
        test_to_iter(empty_set),
        test_to_array(empty_set),
        test_insert_erase_batch(empty_set),
        test_intersect_merge_batch(empty_set),
        test_get_size_batch(empty_set),
        test_large_elements_batch(empty_set),
        test_perf(empty_set, 100000),
    ]
    .run_tests
);
