// Tests for Minilib.Collection.Trait::Map
module MapTests;

import Random;
import Minilib.Common.Common;
import Minilib.Collection.Trait;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
import Minilib.Testing.TestUtilArray;
import Minilib.Trait.Traversable;

test_is_empty:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_is_empty = |empty_map| (
    make_test("test_is_empty") $ |_|
    let map = empty_map;
    assert_true("empty", map.is_empty);;
    let map = map.insert((1, "a"));
    assert_false("not empty", map.is_empty)
);

test_get_size:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_get_size = |empty_map| (
    make_test("test_get_size") $ |_|
    let map = empty_map;
    assert_equal("0", 0, map.get_size);;
    let map = map.insert((1, "a"));
    assert_equal("1", 1, map.get_size)
);

test_contains_key:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_contains_key = |empty_map| (
    make_test("test_contains_key") $ |_|
    let map = empty_map;
    assert_false("not contains_key", map.contains_key(1));;
    let map = map.insert((1, "a"));
    assert_true("contains_key", map.contains_key(1));;
    assert_false("not contains_key 2", map.contains_key(2))
);

test_find:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_find = |empty_map| (
    make_test("test_find") $ |_|
    let map = empty_map;
    assert_equal("find 1", none(), map.find(1));;
    let map = map.insert((1, "a"));
    assert_equal("find 1", some("a"), map.find(1));;
    assert_equal("find 2", none(), map.find(2))
);

test_insert:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_insert = |empty_map| (
    make_test("test_insert") $ |_|
    let map = empty_map;
    let map = map.insert((42, "a"));
    let map = map.insert((42, "b"));
    assert_equal("1", 1, map.get_size);;
    assert_equal("find 42", some("b"), map.find(42));;
    assert_equal("find 43", none(), map.find(43));;
    let map = map.insert((43, "c"));
    let map = map.insert((43, "d"));
    let map = map.insert((42, "e"));
    assert_equal("2", 2, map.get_size);;
    assert_equal("find 42", some("e"), map.find(42));;
    assert_equal("find 43", some("d"), map.find(43))
);

test_erase:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_erase = |empty_map| (
    make_test("test_erase") $ |_|
    let map = empty_map;
    let map = map.erase(42);
    assert_equal("0", 0, map.get_size);;
    assert_equal("find 42", none(), map.find(42));;
    assert_equal("find 43", none(), map.find(43));;
    let map = map.insert((42, "a"));
    let map = map.insert((42, "b"));
    let map = map.insert((43, "c"));
    assert_equal("2", 2, map.get_size);;
    assert_equal("find 42", some("b"), map.find(42));;
    assert_equal("find 43", some("c"), map.find(43));;
    let map = map.erase(42);
    let map = map.erase(42);
    assert_equal("1", 1, map.get_size);;
    assert_equal("find 42", none(), map.find(42));;
    assert_equal("find 43", some("c"), map.find(43))
);

test_set:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_set = |empty_map| (
    make_test("test_set") $ |_|
    let map = empty_map;
    let map = map.Map::set(42, some("a"));
    assert_equal("1", 1, map.get_size);;
    assert_equal("find 42", some("a"), map.find(42));;
    let map = map.Map::set(42, some("b"));
    assert_equal("1", 1, map.get_size);;
    assert_equal("find 42", some("b"), map.find(42));;
    let map = map.Map::set(42, none());
    assert_equal("0", 0, map.get_size);;
    assert_equal("find 42", none(), map.find(42))
);

store: [f: Functor, map: Map] MapKey map -> map ->
 (Option (MapValue map) -> f (Option (MapValue map))) -> f map;
store = |k, map, f|  map.act(k, f);

test_act:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_act = |empty_map| (
    make_test("test_act") $ |_|
    let map = empty_map;
    let map = map.store(42).iset(some("a"));
    assert_equal("size 1", 1, map.get_size);;
    assert_equal("find 42", some("a"), map.find(42));;
    assert_equal("iget 42", some("a"), map.store(42).iget);;
    let map = map.store(42).imod(Functor::map(concat("b")));
    assert_equal("iget 42", some("ab"), map.store(42).iget);;
    let map = map.store(42).iset(none());
    assert_equal("size 0", 0, map.get_size);;
    assert_true("empty", map.is_empty)
);

test_to_iter:
    [map: Map, MapKey map = I64, MapValue map = String, Map::MapIterator map = iter, iter: Iterator, Item iter = (I64, String)]
    map -> TestCase;
test_to_iter = |empty_map| (
    make_test("test_to_iter") $ |_|
    let iter = Iterator::range(0, 10).map(|i| (i, i.to_string));
    let map = iter.fold(empty_map, insert);
    assert_equal("eq", iter.to_array, map.to_iter.Iterator::to_array);;
    pure()
);

test_to_array:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_to_array = |empty_map| (
    make_test("test_to_array") $ |_|
    let iter = Iterator::range(0, 10).map(|i| (i, i.to_string));
    let map = iter.fold(empty_map, insert);
    assert_equal("eq", iter.to_array, map.to_array);;
    pure()
);

test_insert_erase_ok:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> (I64, Reorder, Reorder) -> TestCase;
test_insert_erase_ok = |empty_map, (n, insert_reorder, erase_reorder)| (
    let testname = "test_insert_erase_ok("+ n.to_string + "," +
                    insert_reorder.to_string + "," +
                    erase_reorder.to_string + ")";
    make_test(testname) $ |_|
    let keys_sorted = Iterator::range(0, n).to_array;

    // insert with keys shuffled
    let keys_shuffled = keys_sorted.reorder(insert_reorder);
    let map = keys_shuffled.to_iter.fold(
        empty_map, |k, map|
        map.insert((k, "value-1-" + k.to_string ))
    );

    // assert that the size is same as keys
    assert_equal("size after insertion", keys_sorted.get_size, map.get_size);;

    // assert that keys are sorted
    let keys_current = map.to_array.Functor::map(Tuple2::@0);
    assert_equal("keys are sorted", keys_sorted, keys_current);;

    // assert that keys exist and values are correct
    keys_sorted.to_iter.foreach_m(|k|
        assert_equal("map.contains_key", true, map.contains_key(k));;
        let v = map.find(k);
        assert_equal("map.find", some("value-1-" + k.to_string), v)
    );;

    // change values
    let map = keys_shuffled.to_iter.fold(
        map, |k, map|
        map.insert((k, "value-2-" + k.to_string ))
    );

    // assert that the size is same as keys
    assert_equal("size after change", keys_sorted.get_size, map.get_size);;

    // assert that keys are sorted
    let keys_current = map.to_array.Functor::map(Tuple2::@0);
    assert_equal("keys are sorted", keys_sorted, keys_current);;

    // assert that keys exist and values are correct
    keys_sorted.to_iter.foreach_m(|k|
        assert_equal("map.contains_key", true, map.contains_key(k));;
        let v = map.find(k);
        assert_equal("map.find", some("value-2-" + k.to_string), v)
    );;

    // erase keys
    let keys_shuffled = keys_sorted.reorder(erase_reorder);
    let map = keys_shuffled.to_iter.fold(
        map, |i, map|
        map.erase(i)
    );
    let keys_current = map.to_array.Functor::map(Tuple2::@0);
    assert_equal("[] == keys_current", [], keys_current);;
    assert_true("map.is_empty", map.is_empty);;
    assert_equal("size after erase", 0, map.get_size);;

    pure()      // success
);

test_insert_erase_batch:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_insert_erase_batch = |empty_map| (
    do {
        let n = 30;
        let insert_reorder = *[skip(15), ascending(), descending(), shuffle(123)];
        let erase_reorder = *[skip(15), ascending(), descending(), shuffle(345)];
        pure $ empty_map.test_insert_erase_ok $ (n, insert_reorder, erase_reorder)
    }.run_tests
);


test_get_size_batch:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_get_size_batch = |empty_map| (
    make_table_test(
        "test_get_size_batch",
        [
            (1234, 100, 3),
            (1235, 100, 10),
            (1236, 10, 3),
            (1237, 10, 10),
        ],
        |(seed, n, max_op)|
        let random = Random::init_by_seed(seed.to_U64);
        let mask = Array::fill(n, false);
        let size = 0;
        let map = empty_map;
        loop_m(
            (random, mask, size, map, 0), |(random, mask, size, map, i)|
            if i >= n * 10 { break_m $ () };
            let (random, k) = random.generate_U64;
            let (random, v) = random.generate_U64;
            let (random, op) = random.generate_U64;
            let k = (k % n.to_U64).to_I64;
            let v = (v % n.to_U64).to_I64.to_string;
            let op = (op % max_op.to_U64).to_I64;
            if op == 0 {
                let size = if mask.@(k) { size } else { size + 1 };
                let mask = mask.set(k, true);
                let map = map.insert((k, v));
                assert_equal("insert", size, map.get_size);;
                continue_m $ (random, mask, size, map, i + 1)
            } else if op == 1 {
                let size = if mask.@(k) { size } else { size + 1 };
                let mask = mask.set(k, true);
                let map = map.act(k, |opt_v|
                    let opt_v = match opt_v {
                        none() => some(v),
                        some(vv) => some(vv + "123")
                    };
                    Identity{ data: opt_v }
                ).@data;
                assert_equal("act", size, map.get_size);;
                continue_m $ (random, mask, size, map, i + 1)
            } else {    // op == 2 or above
                let size = if !mask.@(k) { size } else { size - 1 };
                let mask = mask.set(k, false);
                let map = map.erase(k);
                assert_equal("erase", size, map.get_size);;
                continue_m $ (random, mask, size, map, i + 1)
            }
        )
    )
);

test_large_keys_batch:
    [map: Map, MapKey map = I64, MapValue map = String]
    map -> TestCase;
test_large_keys_batch = |empty_map| (
    make_table_test(
        "test_large_keys_batch",
        [
            (12345, 100),
            (12346, 200),
        ],
        |(seed, n)|
        let random = Random::init_by_seed(seed.to_U64);
        let (random, keys) = random.generate_array(n, generate_U64 >> Functor::map(to_I64));
        let keys_sorted = keys.sort.dedup;
        let keys_shuffled =  keys_sorted.reorder(shuffle(seed * 10 + 1));
        let map = keys_shuffled.to_iter.fold(
            empty_map, |key, map|
            map.insert((key, key.to_string))
        );
        let expected = keys_sorted.to_iter.Iterator::map(|key| (key, key.to_string)).to_array;
        let actual = map.to_array;
        assert_equal("eq", expected, actual)
    )
);

test_perf:
    [map: Map, MapKey map = I64, MapValue map = String, Map::MapIterator map = iter, iter: Iterator, Item iter = (I64, String)]
    map -> I64 -> TestCase;
test_perf = |empty_map, n| (
    make_test("test_perf") $ |_|
    //let n = 1000000;
    println("test_perf (n=" + n.to_string + ")").lift;;
    let array = Iterator::range(0, n).map(|k| (k, k.to_string)).to_array;
    let shuffled = array.reorder(shuffle(5432));
    let (map, insert_time) = *consumed_time_while_io(do {
        pure();;
        pure $ shuffled.to_iter.fold(empty_map, insert)
    }).lift;
    println(" insert: " + insert_time.to_string + " seconds").lift;;
    assert_equal("size", n, map.get_size);;
    let (ans1, ans1_time) = *consumed_time_while_io(do {
        pure();;
        pure $ map.to_iter.Iterator::to_array
    }).lift;
    println(" to_iter.to_array: " + ans1_time.to_string + " seconds").lift;;
    assert_equal("eq", ans1, array);;
    let (ans2, ans2_time) = *consumed_time_while_io(do {
        pure();;
        pure $ map.to_array
    }).lift;
    println(" to_array: " + ans2_time.to_string + " seconds").lift;;
    assert_equal("eq", ans2, array);;
    let (map, erase_time) = *consumed_time_while_io(do {
        pure();;
        pure $ shuffled.to_iter.fold(
            map, |(k, v)| erase(k)
        )
    }).lift;
    println(" erase: " + erase_time.to_string + " seconds").lift;;
    assert_equal("size", 0, map.get_size);;
    pure()
);

map_tests:
    [map: Map, MapKey map = I64, MapValue map = String, Map::MapIterator map = iter, iter: Iterator, Item iter = (I64, String)]
    map -> TestCase;
map_tests = |empty_map| (
    [
        test_is_empty(empty_map),
        test_get_size(empty_map),
        test_contains_key(empty_map),
        test_find(empty_map),
        test_insert(empty_map),
        test_erase(empty_map),
        test_set(empty_map),
        test_act(empty_map),
        test_to_iter(empty_map),
        test_to_array(empty_map),
        test_insert_erase_batch(empty_map),
        test_get_size_batch(empty_map),
        test_large_keys_batch(empty_map),
        test_perf(empty_map, 1000000),
    ]
    .run_tests
);
