// Tests for Minilib.Collection.Trait::SortedMap
module SortedMapTests;

import Minilib.Collection.Trait;
import Minilib.Testing.UnitTest;
import Minilib.Testing.TestUtilArray;
import Minilib.Trait.Traversable;

test_select_range:
    [map: SortedMap, MapKey map = I64, MapValue map = String, Map::MapIterator map = iter, iter: Iterator, Item iter = (I64, String)]
    map -> TestCase;
test_select_range = |empty_map| (
    let keys_sorted = Iterator::range(0, 30).to_array;
    let keyvalues_sorted = keys_sorted.Functor::map(|k| (k, (k*10).to_string));
    let keyvalues_shuffled = keyvalues_sorted.reorder(shuffle(345));
    let map = keyvalues_shuffled.to_iter.fold(empty_map, insert);
    make_table_test("test_select_range",
        [
            (included(3), excluded(6), [(3,"30"),(4,"40"),(5,"50")]),
            (excluded(3), included(6), [(4,"40"),(5,"50"),(6,"60")]),
            (included(5), excluded(6), [(5,"50")]),
            (included(5), included(5), [(5,"50")]),
            (included(5), excluded(5), []),
            (included(-1), excluded(1), [(0,"0")]),
            (excluded(28), excluded(31), [(29,"290")]),
            (excluded(10), excluded(14), [(11,"110"), (12,"120"), (13,"130")]),
            (included(28), unbound(), [(28,"280"), (29,"290")]),
            (unbound(), excluded(2), [(0,"0"), (1,"10")]),
            (unbound(), unbound(), keyvalues_sorted),
        ],
        |(begin, end, expected)|
        let actual = map.select_range(begin, end, true).to_array;
        assert_equal("ascending", expected, actual);;
        let actual = map.select_range(begin, end, false).to_array;
        assert_equal("decending", expected.reverse, actual);;
        pure()
    )
);

sorted_map_tests:
    [map: SortedMap, MapKey map = I64, MapValue map = String, Map::MapIterator map = iter, iter: Iterator, Item iter = (I64, String)]
    map -> TestCase;
sorted_map_tests = |empty_map| (
    [
        test_select_range(empty_map),
    ]
    .run_tests
);
