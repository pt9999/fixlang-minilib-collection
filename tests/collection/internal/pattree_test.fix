module PatTreeTest;
//module PatTree3Test;

import Minilib.Collection.Internal.PatTree;
import Minilib.Collection.Trait;
import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;
import Minilib.Testing.TestUtilArray;

test_simple: TestCase;
test_simple = (
    make_test("test_simple") $ |_|
    let println = IO::println >> lift;
    let tree: PTree String = PTree::empty;
    let tree = tree.set__combine(Combine::append);
    let tree = tree.insert((1_U64, "111"));
    let tree = tree.insert((2_U64, "222"));
    let tree = tree.insert((3_U64, "333"));
    let tree = tree.insert((2_U64, "aaa"));
    //println("tree="+tree.to_string);;
    //println("tree.find(2)="+tree.find(2_U64).to_string);;
    assert_equal("find(2)", some("222aaa"), tree.find(2_U64));;     // since we use Combine::append

    //println("erasing 7");;
    let tree = tree.erase(7_U64);
    //println(tree.to_string);;
    assert_equal("find(7)", none(), tree.find(7_U64));;

    let tree = *tree.to_array.to_iter.fold_m(
        tree, |(key, value), tree|
        //println("erasing " + key.to_string);;
        let tree = tree.erase(key);
        //println("tree=" + tree.to_string);;
        //println("tree.find("+key.to_string+")=" + tree.find(key).to_string);;
        assert_equal("find after erase", none(), tree.find(key));;
        pure $ tree
    );
    assert_equal("root", tree.@_root, PNodeIndex::empty);;
    pure()
);

test_perf: I64 -> TestCase;
test_perf = |n| (
    make_test("test_perf") $ |_|
    //let n = 1000000;
    //let n = 100000;
    //let n = 100;
    println("PatTreeTest::test_perf (n=" + n.to_string + ")").lift;;
    let array = Iterator::range(0, n).to_array;
    let array = array.map(|x| (x * 12345) % 998244353);
    let array = array.reorder(shuffle(345));
    let (tree, insert_time) = *consumed_time_while_io(do {
        pure();;
        pure $ range(0,n).fold(
            PTree::empty, |i, tree|
            //eval if i % 10000 == 0 { debug_eprintln(i.to_string) } else { () };
            tree.insert((array.@(i).to_U64, i)))
    }).lift;
    println(" insert: " + insert_time.to_string + " seconds").lift;;
    assert_equal("size", n, tree.get_size);;
/*
    let (_, find_time) = *consumed_time_while_io(do {
        pure();;
        pure $ range(0,n).fold(
            0, |i, ans|
            let opt = tree.find(array.@(i).to_U64);
            //eval if i % 10000 == 0 { debug_eprintln(i.to_string) } else { () };
            //eval debug_eprintln(array.@(i).to_string + " -> " + i.to_string);
            if opt != some(i) { undefined("find fail: " + opt.to_string) };
            ans + opt.as_some
        )
    }).lift;
    println(" find_time=" + find_time.to_string_precision(3_U8) + " sec");;
*/
    let (arr, to_iter_to_array_time) = *consumed_time_while_io(do {
        pure();;
        pure $ tree.to_iter.to_array
    }).lift;
    println(" to_iter.to_array: " + to_iter_to_array_time.to_string + " seconds").lift;;
    let (arr2, to_array_time) = *consumed_time_while_io(do {
        pure();;
        pure $ tree.to_array
    }).lift;
    println(" to_array: " + to_array_time.to_string + " seconds").lift;;
    assert_equal("arr == arr2", arr, arr2);;
    let (tree, erase_time) = *consumed_time_while_io(do {
        pure();;
        pure $ array.to_iter.fold(
            tree, |x, tree| tree.erase(x.to_U64)
        )
    }).lift;
    println(" erase: " + erase_time.to_string + " seconds").lift;;
    assert_equal("size", 0, tree.get_size);;
    pure()
);

main: IO () = (
    [
        // here we cannot use `MapTests::map_tests` since `MapKey (PTree a)` is U64
        test_simple,
        test_perf(100000),
    ]
    .run_test_driver
);
