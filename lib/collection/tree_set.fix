// TreeSet is a set that manages elements in sorted order.
//
// `TreeSet` implements the `Set` and `SortedSet` trait, so if you use `TreeSet`,
// you may also need to import `Minilib.Collection.Trait.Set` and `Minilib.Collection.Trait.SortedSet`.
//
// The elements of a TreeSet must have a partial order,
// and `less_than` is the comparison function for that partial order.
//
// NOTE: `less_than()` function must meet following conditions.
// - Irreflexivity: for all `x`, `less_than(x,x)` must be false.
// - Asymmetry:     for all `x, y`, if `less_than(x,y)` is true, then `less_than(y,x)` must be false.
// - Transitivity:  for all `x, y, z`, if `less_than(x,y)` is true and `less_than(y,z)` is true,
//                  then `less_than(x,z)` must be true.
//
// If two elements `x` and `y` are incomparable, i.e. neither `less_than(x,y)` nor `less_than(y,x)` holds,
// then `x` and `y` are considered equivalent.
module Minilib.Collection.TreeSet;

import Minilib.Collection.Internal.RBTree;
import Minilib.Collection.Trait.Set;
import Minilib.Collection.Trait.SortedSet;

namespace TreeSet {
    // A trait of the element. Currently `ToString` is required.
    trait TreeSetElem = ToString;

    // A type of set that manages elements in sorted order.
    type TreeSet a = unbox struct {
        root: RBNode a,
        size: I64,
        less_than: a -> a -> Bool
    };

    // `TreeSet::make()` creates an empty `TreeSet` using default `LessThan` ordering.
    make: [a: TreeSetElem, a: LessThan] () -> TreeSet a;
    make = |_| (
        make_lt(|x,y| x < y)
    );

    // `TreeSet::make_lt(less_than)` creates an empty `TreeSet` using specified ordering.
    //
    // # Parameters
    // - `less_than`: a comparision function
    make_lt: [a: TreeSetElem] (a -> a -> Bool) -> TreeSet a;
    make_lt = |less_than| (
        TreeSet {
            root: RBNode::empty(),
            size: 0,
            less_than: less_than
        }
    );

    _mod_root_and_size: (RBNode a -> (I64, RBNode a)) -> TreeSet a -> TreeSet a;
    _mod_root_and_size = |f, ts| (
        let (dsize, ts) = ts.act_root(f);
        ts.mod_size(add(dsize))
    );

    // Inserts an element into a TreeSet.
    // For example, `ts.insert(x)` inserts `x` into `ts`.
    //
    // NOTE: If `ts` already contains an element `y` equivalent to `x`,
    // ie. `!less_than(x,y) && !less_than(y,x)` is true,
    // then `y` is replaced with `x`.
    _insert: [a: TreeSetElem] a -> TreeSet a -> TreeSet a;
    _insert = |x, ts| (
       ts._mod_root_and_size(insert_lt(x, ts.@less_than))
    );

    // Erases an element from a TreeSet.
    // For example, `ts.erase(x)` removes `x` from `ts`.
    //
    // NOTE: If `ts` contains an element `y` equivalent to `x`,
    // ie. `!less_than(x,y) && !less_than(y,x)` is true,
    // then `y` is removed.
    _erase: [a: TreeSetElem] a -> TreeSet a -> TreeSet a;
    _erase = |x, ts| (
       ts._mod_root_and_size(remove_lt(x, ts.@less_than))
    );

    // Checks whether a TreeSet is empty.
    _is_empty: [a: TreeSetElem] TreeSet a -> Bool;
    _is_empty = |ts| (
        ts.@root.is_empty
    );

    // Gets the number of elements.
    // The time complexity of this function is O(1).
    _get_size: TreeSet a -> I64;
    _get_size = |ts| (
        ts.@size
    );

    // Checks whether a TreeSet contains an element.
    _contains: [a: TreeSetElem] a -> TreeSet a -> Bool;
    _contains = |x, ts| (
        ts.@root.find(x, ts.@less_than).is_some
    );

    _select_range: [a: TreeSetElem] Option a -> Option a -> Bool -> TreeSet a -> DynIterator a;
    _select_range = |begin, end, ascending, ts| (
        let less_than = ts.@less_than;
        let lt_begin = match begin {
            none() => |x| false,
            some(begin) => |x| less_than(x, begin)
        };
        let lt_end   = match end {
            none() => |x| true,
            some(end) => |x| less_than(x, end)
        };
        if ascending { ts.@root.find_range(lt_begin, lt_end) }
        else { ts.@root.find_range_descending(lt_begin, lt_end) }
    );

    // Deprecated: use `select_range`.
    //
    // `ts.find_range(begin, end)` finds all elements `x`
    // where `!less_than(x, begin) && less_than(x, end)` is true.
    // In default `LessThan` ordering, that condition is same as `begin <= x && x < end`.
    //
    // # Parameters
    // - `begin`: the beginning of range
    // - `end`: the end of range
    // - `ts`: a TreeSet
    find_range: [a: TreeSetElem] a -> a -> TreeSet a -> DynIterator a;
    find_range = |begin, end, ts| (
        let less_than = ts.@less_than;
        let lt_begin = |x| less_than(x, begin);
        let lt_end   = |x| less_than(x, end);
        ts.@root.find_range(lt_begin, lt_end)
    );

    // Deprecated: use `select_range`.
    //
    // `ts.find_range(begin, end)` finds all elements `x`
    // where `!less_than(x, begin) && less_than(x, end)` is true,  in descending order.
    // In default `LessThan` ordering, that condition is same as `begin <= x && x < end`.
    //
    // # Parameters
    // - `begin`: the beginning of range
    // - `end`: the end of range
    // - `ts`: a TreeSet
    find_range_descending: [a: TreeSetElem] a -> a -> TreeSet a -> DynIterator a;
    find_range_descending = |begin, end, ts| (
        let less_than = ts.@less_than;
        let lt_begin = |x| less_than(x, begin);
        let lt_end   = |x| less_than(x, end);
        ts.@root.find_range_descending(lt_begin, lt_end)
    );

    // `ts.find_raw_range(lt_begin, lt_end)` finds all elements `x`
    // where `!lt_begin(x) && lt_end(x)` is true.
    // NOTE: `lt_begin` and `lt_end` must meet following condition:
    // for all `x`, `x.lt_begin` is true then `x.lt_end` must be true.
    //
    // # Parameters
    // - `lt_begin`: a function that determines the beginning of range
    // - `lt_end`: a function that determines the end of range
    // - `ts`: a TreeSet
    find_raw_range: [a: TreeSetElem] (a -> Bool) -> (a -> Bool) -> TreeSet a -> DynIterator a;
    find_raw_range = |lt_begin, lt_end, ts| (
        ts.@root.find_range(lt_begin, lt_end)
    );

    // `ts.find_raw_range_descending(lt_begin, lt_end)` finds all elements `elem`
    // such that `!lt_begin(x) && lt_end(x)` is true, in descending order.
    // NOTE: `lt_begin` and `lt_end` must meet following condition:
    // for all `x`, `x.lt_begin` is true then `x.lt_end` must be true.
    //
    // # Parameters
    // - `lt_begin`: a function that determines the beginning of range
    // - `lt_end`: a function that determines the end of range
    // - `ts`: a TreeSet
    find_raw_range_descending: [a: TreeSetElem] (a -> Bool) -> (a -> Bool) -> TreeSet a -> DynIterator a;
    find_raw_range_descending = |lt_begin, lt_end, ts| (
        ts.@root.find_range_descending(lt_begin, lt_end)
    );

    // Converts a TreeSet into an array in sorted order.
    //
    // # Parameters
    // - `ts`: a TreeSet
    _to_array: [a: TreeSetElem] TreeSet a -> Array a;
    _to_array = |ts| (
        ts.@root.to_array
    );

    // Converts a TreeSet into an iterator in sorted order.
    _to_iter: [a: TreeSetElem] TreeSet a -> DynIterator a;
    _to_iter = |ts| (
        ts.@root.to_iter
    );

    // Converts an iterator into a TreeSet using specified ordering.
    //
    // # Parameters
    // - `less_than`: a comparision function
    // - `iter`: an iterator of elements
    from_iter_lt: [a: TreeSetElem, it: Iterator, Item it = a] (a -> a -> Bool) -> it -> TreeSet a;
    from_iter_lt = |less_than, iter| (
        let node = RBNode::from_iter_lt(less_than, iter);
        TreeSet {
            root: node,
            size: node.get_size,
            less_than: less_than
        }
    );

    // Converts an iterator into a TreeSet using default `LessThan` ordering.
    //
    // # Parameters
    // - `iter`: an iterator of elements
    from_iter: [a: LessThan, a: TreeSetElem, it: Iterator, Item it = a] it -> TreeSet a;
    from_iter = |iter| (
        TreeSet::from_iter_lt(RBNode::_less_than, iter)
    );

    // Calculates intersection of two TreeSets.
    //
    // # Parameters
    // - `ts1`: a TreeSet
    // - `ts2`: another TreeSet
    intersect: [a : TreeSetElem] TreeSet a -> TreeSet a -> TreeSet a;
    intersect = |ts1, ts2| (
        ts1.to_iter.fold(
            ts1, |x, ts1|
            if ts2.contains(x) {
                ts1
            } else {
                ts1.erase(x)
            }
        )
    );

    // Calculates union of two TreeSets.
    //
    // # Parameters
    // - `ts1`: a TreeSet
    // - `ts2`: another TreeSet
    merge: [a : TreeSetElem] TreeSet a -> TreeSet a -> TreeSet a;
    merge = |ts1, ts2| (
        ts2.to_iter.fold(
            ts1, |x, ts1|
            ts1.insert(x)
        )
    );
}

// Implementation of the `Set` trait.
impl [a: TreeSetElem] TreeSet a: Set {
    type SetElem (TreeSet a) = a;
    type SetIterator (TreeSet a) = DynIterator a;

    is_empty = TreeSet::_is_empty;
    get_size = TreeSet::_get_size;
    contains = TreeSet::_contains;
    insert = TreeSet::_insert;
    erase = TreeSet::_erase;
    to_iter = TreeSet::_to_iter;
    to_array = TreeSet::_to_array;
    //from_iter = TreeSet::_from_iter;
}

impl [a: TreeSetElem] TreeSet a: SortedSetIF {
    //find_range = TreeSet::_find_range;
    //find_range_descending = TreeSet::_find_range_descending;
    select_range = TreeSet::_select_range;
}

// Converts a TreeSet into a String.
impl [a: TreeSetElem] TreeSet a: ToString {
    to_string = |ts| (
        "TreeSet{" + ts.to_iter.Iterator::map(to_string).join(",") + "}"
    );
}
