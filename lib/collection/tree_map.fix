// TreeMap is a map that manages keys in sorted order.
//
// The keys of a TreeSet must have a partial order,
// and `less_than` is the comparison function for that partial order.
//
// NOTE: `less_than()` function must meet following conditions.
// - Irreflexivity: for all `x`, `less_than(x,x)` must be false.
// - Asymmetry:     for all `x, y`, if `less_than(x,y)` is true, then `less_than(y,x)` must be false.
// - Transitivity:  for all `x, y, z`, if `less_than(x,y)` is true and `less_than(y,z)` is true,
//                  then `less_than(x,z)` must be true.
//
// If two keys `x` and `y` are incomparable, i.e. neither `less_than(x,y)` nor `less_than(y,x)` holds,
// then `x` and `y` are considered equivalent.
module Minilib.Collection.TreeMap;

import Minilib.Collection.RBTree;
import Minilib.Collection.Trait.Map;
import Minilib.Text.StringEx;

namespace TreeMap {
    // A trait of the key. Currently `ToString` is required.
    trait TreeMapKey = ToString;

    // A trait of the value. Currently `ToString` is required.
    trait TreeMapValue = ToString;

    // Converts key_less_than to entry_less_than.
    _lift_lt: (k -> k -> Bool) -> (k, v) -> (k, v) -> Bool;
    _lift_lt = |key_less_than, (k1, v1), (k2, v2)| (
        key_less_than(k1, k2)
    );

    // `TreeMap` is a structure that stores key-value pairs into a red-black tree.
    type TreeMap k v = unbox struct {
        root: RBNode (k, v),
        size: I64,
        key_less_than: k -> k -> Bool,
        entry_less_than: (k, v) -> (k, v) -> Bool
    };

    // `TreeMap::make()` creates an empty `TreeMap` using default `LessThan` ordering.
    make: [k: LessThan, k: TreeMapKey, v: TreeMapValue] () -> TreeMap k v;
    make = |_| (
        make_lt(RBNode::_less_than)
    );

    // `TreeMap::make_lt(less_than)` creates an empty `TreeMap` using specified ordering.
    // NOTE: `less_than` function must meet specific conditions. For details, see documentation of 
    // [`RBTree`](./rbtree.md).
    make_lt: [k: TreeMapKey, v: TreeMapValue] (k -> k -> Bool) -> TreeMap k v;
    make_lt = |key_less_than| (
        TreeMap {
            root: RBNode::empty(),
            size: 0,
            key_less_than: key_less_than,
            entry_less_than: _lift_lt(key_less_than)
        }
    );

    _mod_root_and_size: (RBNode (k, v) -> (I64, RBNode (k, v))) -> TreeMap k v -> TreeMap k v;
    _mod_root_and_size = |f, tm| (
        let (dsize, tm) = tm.act_root(f);
        tm.mod_size(add(dsize))
    );

    // Inserts an entry into a TreeMap.
    // For example, `tm.insert(k, v)` inserts an entry `(k,v)` into `tm`.
    //
    // NOTE: If `tm` already contains an entry `(k1,v1)`
    // where the key `k1` is equivalent to `k`,
    // ie. `!less_than(k,k1) && !less_than(k1,k)` is true,
    // then `(k1,v1)` is replaced with `(k,v)`.
    _insert: [k: TreeMapKey, v: TreeMapValue] k -> v -> TreeMap k v -> TreeMap k v;
    _insert = |k, v, tm| (
       tm._mod_root_and_size(insert_lt((k, v), tm.@entry_less_than))
    );

    // Inserts or updates an entry in a TreeMap.
    // For example, `tm.upsert(k, v, updater)` inserts an entry `(k,v)` into `tm`.
    //
    // NOTE: If `tm` already contains an entry `(k1,v1)`
    // where the key `k1` is equivalent to `k`,
    // ie. `!less_than(k,k1) && !less_than(k1,k)` is true,
    // then `(k1,v1)` is replaced with `(k, updater(v1))`.
    upsert: [k: TreeMapKey, v: TreeMapValue] k -> v -> (v -> v) -> TreeMap k v -> TreeMap k v;
    upsert = |k, v, updater, tm| (
       tm._mod_root_and_size(upsert_lt((k, v), |(k1,v1)| (k,updater(v1)), tm.@entry_less_than))
    );

    // Erases an entry from a TreeMap.
    // For example, `tm.erase(k)` removes an entry `(k,v)` from `tm`.
    //
    // NOTE: If `tm` contains an entry `(k1,v1)`
    // where the key `k1` is equivalent to `k`,
    // ie. `!less_than(k,k1) && !less_than(k1,k)` is true,
    // then `(k1,v1)` is removed.
    _erase: [k: TreeMapKey, v: TreeMapValue] k -> TreeMap k v -> TreeMap k v;
    _erase = |k, tm| (
        let less_than = tm.@key_less_than;
        let lt_begin = |(ent_k,_)| less_than(ent_k, k);
        let lt_end   = |(ent_k,_)| !less_than(k, ent_k);
        tm._mod_root_and_size(remove_range(lt_begin, lt_end))
    );

    // Checks whether a TreeMap is empty.
    _is_empty: [k: TreeMapKey, v: TreeMapValue] TreeMap k v -> Bool;
    _is_empty = |tm| (
        tm.@root.is_empty
    );

    // Gets the number of entries.
    // The time complexity of this function is O(1).
    _get_size: [k: TreeMapKey, v: TreeMapValue] TreeMap k v -> I64;
    _get_size = |tm| (
        tm.@size
    );

    // Checks whether a TreeMap contains a key.
    _contains_key: [k: TreeMapKey, v: TreeMapValue] k -> TreeMap k v -> Bool;
    _contains_key = |k, tm| (
        tm.find(k).is_some
    );

    // Returns an iterator of keys in ascending order.
    keys: [k: TreeMapKey, v: TreeMapValue] TreeMap k v -> DynIterator k;
    keys = |tm| (
        tm.to_iter.map(|e| e.@0)
    );

    // Finds an element from a TreeMap.
    _find: [k: TreeMapKey, v: TreeMapValue] k -> TreeMap k v -> Option v;
    _find = |k, tm| (
        let less_than = tm.@key_less_than;
        let lt_begin = |(ent_k,_)| less_than(ent_k, k);
        let lt_end   = |(ent_k,_)| !less_than(k, ent_k);
        let iter = tm.@root.find_range(lt_begin, lt_end);
        iter.get_first.map(|entry| entry.@1)
    );

    // `tm.find_range(begin, end)` finds all entries `(k,v)`
    // where `!less_than(k, begin) && less_than(k, end)` is true.
    // In default `LessThan` ordering, that condition is same as `begin <= k && k < end`.
    find_range: [k: TreeMapKey, v: TreeMapValue] k -> k -> TreeMap k v -> DynIterator (k, v);
    find_range = |begin, end, tm| (
        let less_than = tm.@key_less_than;
        let lt_begin = |(ent_k,_)| less_than(ent_k, begin);
        let lt_end   = |(ent_k,_)| less_than(ent_k, end);
        tm.@root.find_range(lt_begin, lt_end)
    );

    // `tm.find_raw_range(lt_begin, lt_end)` finds all entries `(k,v)`
    // where `!lt_begin((k, v)) && lt_end((k, v))` is true.
    // NOTE: `lt_begin` and `lt_end` must meet following condition:
    // for all `(k,v)`, `lt_begin((k,v))` is true then `lt_end((k,v))` must be true.
    find_raw_range: [k: TreeMapKey, v: TreeMapValue] ((k,v) -> Bool) -> ((k,v) -> Bool) -> TreeMap k v -> DynIterator (k, v);
    find_raw_range = |lt_begin, lt_end, tm| (
        tm.@root.find_range(lt_begin, lt_end)
    );

    // Converts a TreeMap into an array of key-value pairs in ascending order of keys.
    to_array: [k: TreeMapKey, v: TreeMapValue] TreeMap k v -> Array (k, v);
    to_array = |tm| (
        tm.@root.to_array
    );

    // Converts a TreeMap into an iterator of key-value pairs in ascending order of keys.
    _to_iter: [k: TreeMapKey, v: TreeMapValue] TreeMap k v -> DynIterator (k, v);
    _to_iter = |tm| (
        tm.@root.to_iter
    );

    // Converts an iterator of key-value pairs into a TreeMap using specified ordering.
    from_iter_lt: [k: TreeMapKey, v: TreeMapValue, it: Iterator, Item it = (k, v)] (k -> k -> Bool) -> it -> TreeMap k v;
    from_iter_lt = |key_less_than, iter| (
        let tm = TreeMap::make_lt(key_less_than);
        let root = RBNode::from_iter_lt(tm.@entry_less_than, iter);
        tm.set_root(root).set_size(root.get_size)
    );

    // Converts an iterator of key-value pairs into a TreeMap using default `LessThan` ordering.
    from_iter: [k: LessThan, k: TreeMapKey, v: TreeMapValue, it: Iterator, Item it = (k, v)] it -> TreeMap k v;
    from_iter = |iter| (
        TreeMap::from_iter_lt(RBNode::_less_than, iter)
    );
}


impl [k: TreeMapKey, v: TreeMapValue] TreeMap k v: Map {
    type MapKey (TreeMap k v) = k;
    type MapValue (TreeMap k v) = v;
    type MapIterator (TreeMap k v) a = DynIterator a;

    insert = _insert;
    erase = _erase;
    is_empty = _is_empty;
    get_size = _get_size;
    contains_key = _contains_key;
    find = _find;
    to_iter = _to_iter;
    //from_iter = _from_iter;
}

impl [k: TreeMapKey, v: TreeMapValue] TreeMap k v: ToString {
    to_string = |tm| (
        "TreeMap{" + tm.to_iter.Iterator::map(to_string).join(",") + "}"
    );
}
