// `PTreeSet` is a set that manages elements in sorted order.
//
// The elements of a `PTreeSet` can be of type `I64`, `I32`, `I16`, `I8`, `U64`,
// `U32`, `U16`, or `U8`. It's limited, but fast.
//
// The order of elements is fixed to ascending order and cannot be changed to descending order.
//
// `PTreeSet` implements the `Set` and `SortedSet` trait.
//  If you import this module, you should also import `Minilib.Collection.Trait`.
//
// `PTreeSet` manages elements as a node array.
// If you modify the `PTreeSet`, make sure it is unique, otherwise the entire node array will be copied.
//
// `PTreeSet` is built upon [a Patricia Tree](https://en.wikipedia.org/wiki/Radix_tree).
// In particular, I implemented the Patricia Tree with reference to the following paper:
// [Chris Okasaki and Andy Gill, "Fast Mergeable Integer Maps"](https://web.archive.org/web/20150417234429/https://ittc.ku.edu/~andygill/papers/IntMap98.pdf).
//
// ## Benchmark Result
// ```
// test_perf (n=1000000)
//  insert: 0.925837 seconds
//  to_iter.to_array: 0.206471 seconds
//  to_array: 0.101298 seconds
//  erase: 0.955463 seconds
// ```
module Minilib.Collection.PTreeSet;

import Minilib.Collection.Internal.PatTree;
import Minilib.Collection.Trait;
import Minilib.Text.StringEx;

// The trait of elements of a PTreeSet.
trait e : PTreeSetElem {
    // Converts from `e` to an internal key.
    _to_pattree_key: e -> PatTree::PKey;
    // Converts from an internal key to `e`.
    _from_pattree_key: PatTree::PKey -> e;
}

namespace PTreeSetElem {
    // Converts from `(PatTree::PKey, v)` to `e`.
    _from_pattree_kv: [e : PTreeSetElem] (PatTree::PKey, v) -> e;
    _from_pattree_kv = |(key, v)| key._from_pattree_key;
}

// An offset from I64 to U64.
_pattree_key_offset: U64;
_pattree_key_offset = 1_U64.shift_left(63_U64);
//_pattree_key_offset = 0_U64;     // for debug

impl I64: PTreeSetElem {
    _to_pattree_key = |i64| i64.to_U64 + _pattree_key_offset;
    _from_pattree_key = |u64| (u64 - _pattree_key_offset).to_I64;
}

impl I32: PTreeSetElem {
    _to_pattree_key = |i32| i32.to_U64 + _pattree_key_offset;
    _from_pattree_key = |u64| (u64 - _pattree_key_offset).to_I32;
}

impl I16: PTreeSetElem {
    _to_pattree_key = |i16| i16.to_U64 + _pattree_key_offset;
    _from_pattree_key = |u64| (u64 - _pattree_key_offset).to_I16;
}

impl I8: PTreeSetElem {
    _to_pattree_key = |i8| i8.to_U64 + _pattree_key_offset;
    _from_pattree_key = |u64| (u64 - _pattree_key_offset).to_I8;
}

impl U64: PTreeSetElem {
    _to_pattree_key = |u64| u64;
    _from_pattree_key = |u64| u64;
}

impl U32: PTreeSetElem {
    _to_pattree_key = |u32| u32.to_U64;
    _from_pattree_key = |u64| u64.to_U32;
}

impl U16: PTreeSetElem {
    _to_pattree_key = |u16| u16.to_U64;
    _from_pattree_key = |u64| u64.to_U16;
}

impl U8: PTreeSetElem {
    _to_pattree_key = |u8| u8.to_U64;
    _from_pattree_key = |u64| u64.to_U8;
}

// The type of Patricia Tree Sets.
type PTreeSet e = unbox struct {
    // The internal Patricia Tree.
    tree: PTree (),
};

// An empty PTreeSet.
empty: [e: PTreeSetElem] PTreeSet e;
empty = PTreeSet { tree: empty };

impl [e: PTreeSetElem] PTreeSet e: Set {
    type SetElem (PTreeSet e) = e;
    type SetIterator (PTreeSet e) = Std::Iterator::MapIterator (PTreeIterator ()) (PatTree::PKey, ()) e;

    is_empty = |set| set.@tree.is_empty;
    get_size = |set| set.@tree.get_size;
    contains = |e, set| set.@tree.contains_key(e._to_pattree_key);
    insert = |e, set| set.mod_tree(insert((e._to_pattree_key, ())));
    erase = |e, set| set.mod_tree(erase(e._to_pattree_key));
    // TODO: implement fast intersect and merge for PTreeSet
    intersect = Set::Default::default_intersect;
    merge = Set::Default::default_merge;
    to_iter = |set| set.@tree.to_iter.Iterator::map(_from_pattree_kv);
    to_array = |set| set.@tree.to_array.Functor::map(_from_pattree_kv);
    //from_iter = PTree::_from_iter;
}

impl [e: PTreeSetElem] PTreeSet e: SortedSetIF {
    select_range = |lower_bound, upper_bound, ascending, set| (
        let lower_bound = lower_bound.Functor::map(_to_pattree_key);
        let upper_bound = upper_bound.Functor::map(_to_pattree_key);
        set.@tree.select_range(lower_bound, upper_bound, ascending)
        .Iterator::map(_from_pattree_kv)
    );
}
