// `PTreeMap` is a map that manages keys in sorted order.
//
// The keys of a `PTreeSet` can be of type `I64`, `I32`, `I16`, `I8`, `U64`,
// `U32`, `U16`, or `U8`. It's limited, but fast.
//
// `PTreeMap` implements the `Map` and `SortedMap` trait.
//  If you import this module, you should also import `Minilib.Collection.Trait`.
//
// `PTreeMap` is built upon [a Patricia Tree](https://en.wikipedia.org/wiki/Radix_tree).
// In particular, I implemented the Patricia Tree with reference to the following paper:
// [Chris Okasaki and Andy Gill, "Fast Mergeable Integer Maps"](https://web.archive.org/web/20150417234429/https://ittc.ku.edu/~andygill/papers/IntMap98.pdf).
//
module Minilib.Collection.PTreeMap;

import Minilib.Collection.Internal.PatTree;
import Minilib.Collection.Trait;
import Minilib.Text.StringEx;

// The trait of keys of a PTreeMap.
trait k : PTreeMapKey {
    // Converts from `k` to an internal key.
    _to_pattree_key: k -> PatTree::Key;
    // Converts from an internal key to `k`.
    _from_pattree_key: PatTree::Key -> k;
}

namespace PTreeMapKey {
    // Converts from `(PatTree::Key, v)` to `(k, v)`.
    _from_pattree_kv: [k : PTreeMapKey] (PatTree::Key, v) -> (k, v);
    _from_pattree_kv = |(key, v)| (key._from_pattree_key, v);
}

// An offset from I64 to U64.
_pattree_key_offset: U64;
_pattree_key_offset = 1_U64.shift_left(63_U64);
//_pattree_key_offset = 0_U64;     // for debug

impl I64: PTreeMapKey {
    _to_pattree_key = |i64| i64.to_U64 + _pattree_key_offset;
    _from_pattree_key = |u64| (u64 - _pattree_key_offset).to_I64;
}

impl I32: PTreeMapKey {
    _to_pattree_key = |i32| i32.to_U64 + _pattree_key_offset;
    _from_pattree_key = |u64| (u64 - _pattree_key_offset).to_I32;
}

impl I16: PTreeMapKey {
    _to_pattree_key = |i16| i16.to_U64 + _pattree_key_offset;
    _from_pattree_key = |u64| (u64 - _pattree_key_offset).to_I16;
}

impl I8: PTreeMapKey {
    _to_pattree_key = |i8| i8.to_U64 + _pattree_key_offset;
    _from_pattree_key = |u64| (u64 - _pattree_key_offset).to_I8;
}

impl U64: PTreeMapKey {
    _to_pattree_key = |u64| u64;
    _from_pattree_key = |u64| u64;
}

impl U32: PTreeMapKey {
    _to_pattree_key = |u32| u32.to_U64;
    _from_pattree_key = |u64| u64.to_U32;
}

impl U16: PTreeMapKey {
    _to_pattree_key = |u16| u16.to_U64;
    _from_pattree_key = |u64| u64.to_U16;
}

impl U8: PTreeMapKey {
    _to_pattree_key = |u8| u8.to_U64;
    _from_pattree_key = |u64| u64.to_U8;
}

// The type of Patricia Tree Maps.
type PTreeMap k v = unbox struct {
    // The internal Patricia Tree.
    tree: PTree v,
};

// The type of Patricia Tree Maps whose keys are of type `I64`.
type PTreeMapI64 = PTreeMap I64;

// The type of Patricia Tree Maps whose keys are of type `U64`.
type PTreeMapU64 = PTreeMap U64;

// An empty PTreeMap.
empty: [k: PTreeMapKey] PTreeMap k v;
empty = PTreeMap { tree: empty };

impl [k: PTreeMapKey] PTreeMap k v: Map {
    type MapKey (PTreeMap k v) = k;
    type MapValue (PTreeMap k v) = v;
    type MapIterator (PTreeMap k v) = Std::Iterator::MapIterator (PTreeIterator v) (PatTree::Key, v) (k, v);

    is_empty = |map| map.@tree.is_empty;
    get_size = |map| map.@tree.get_size;
    contains_key = |k, map| map.@tree.contains_key(k._to_pattree_key);
    find = |k, map| map.@tree.find(k._to_pattree_key);
    insert = |(k, v), map| map.mod_tree(insert((k._to_pattree_key, v)));
    erase = |k, map| map.mod_tree(erase(k._to_pattree_key));
    set = |k, opt_v, map| map.mod_tree(set(k._to_pattree_key, opt_v));
    act = |k, fun, map| map.act_tree(act(k._to_pattree_key, fun));
    to_iter = |map| map.@tree.to_iter.Iterator::map(_from_pattree_kv);
    to_array = |map| map.@tree.to_array.Functor::map(_from_pattree_kv);
    //from_iter = PTree::_from_iter;
}

impl [k: PTreeMapKey] PTreeMap k v: SortedMapIF {
    select_range = |begin, end, ascending, map| (
        let begin = begin.Functor::map(_to_pattree_key);
        let end = end.Functor::map(_to_pattree_key);
        map.@tree.select_range(begin, end, ascending)
        .Iterator::map(_from_pattree_kv)
    );
}
