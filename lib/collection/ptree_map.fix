// PTreeMap is a map that manages keys in sorted order.
//
// `PTreeMap` implements the `Map` and `SortedMap` trait, so if you use `PTreeMap`,
// you may also need to import `Minilib.Collection.Trait.Map` and `Minilib.Collection.Trait.SortedMap`.
//
// The keys of a PTreeMap are one of I64, U64.
module Minilib.Collection.PTreeMap;

import Minilib.Collection.Internal.PatTree;
import Minilib.Collection.Trait.Map;
import Minilib.Collection.Trait.SortedMap;
import Minilib.Text.StringEx;

trait k : PTreeMapKey {
    to_pattree_key: k -> PatTree::Key;
    from_pattree_key: PatTree::Key -> k;
}

namespace PTreeMapKey {
    from_pattree_kv: [k : PTreeMapKey] (PatTree::Key, v) -> (k, v);
    from_pattree_kv = |(key, v)| (key.from_pattree_key, v);
}

pattree_key_offset: U64;
pattree_key_offset = 1_U64.shift_left(63_U64);
//pattree_key_offset = 0_U64;     // for debug

impl I64: PTreeMapKey {
    to_pattree_key = |i64| i64.to_U64 + pattree_key_offset;
    from_pattree_key = |u64| (u64 - pattree_key_offset).to_I64;
}

impl U64: PTreeMapKey {
    to_pattree_key = |u64| u64;
    from_pattree_key = |u64| u64;
}

type PTreeMap k v = unbox struct {
    tree: PTree v,
};

type PTreeMapI64 = PTreeMap I64;
type PTreeMapU64 = PTreeMap U64;

empty: [k: PTreeMapKey] PTreeMap k v;
empty = PTreeMap { tree: empty };

impl [k: PTreeMapKey] PTreeMap k v: Map {
    type MapKey (PTreeMap k v) = k;
    type MapValue (PTreeMap k v) = v;
    type MapIterator (PTreeMap k v) = Std::Iterator::MapIterator (PTreeIterator v) (PatTree::Key, v) (k, v);

    is_empty = |map| map.@tree.is_empty;
    get_size = |map| map.@tree.get_size;
    contains_key = |k, map| map.@tree.contains_key(k.to_pattree_key);
    find = |k, map| map.@tree.find(k.to_pattree_key);
    insert = |k, v, map| map.mod_tree(insert(k.to_pattree_key, v));
    erase = |k, map| map.mod_tree(erase(k.to_pattree_key));
    set = |k, opt_v, map| map.mod_tree(set(k.to_pattree_key, opt_v));
    act = |k, fun, map| map.act_tree(act(k.to_pattree_key, fun));
    to_iter = |map| map.@tree.to_iter.Iterator::map(from_pattree_kv);
    to_array = |map| map.@tree.to_array.Functor::map(from_pattree_kv);
    //from_iter = PTree::_from_iter;
}

impl [k: PTreeMapKey] PTreeMap k v: SortedMapIF {
    select_range = |begin, end, ascending, map| (
        let begin = begin.Functor::map(to_pattree_key);
        let end = end.Functor::map(to_pattree_key);
        map.@tree.select_range(begin, end, ascending)
        .Iterator::map(from_pattree_kv)
    );
}

