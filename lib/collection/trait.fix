// Trait definitions and default implementations for `Minilib.Collection.*`.
module Minilib.Collection.Trait;

//---------------------------------------------------------------------------
//  Set
//---------------------------------------------------------------------------

// The trait for abstract sets.
trait set: Set {
    // The type of the elements.
    type SetElem set;
    // The type of the iterator returned by `to_iter`.
    // `Item (SetIterator set)` should be equal to `SetElem set`.
    type SetIterator set;

    // Checks whether a set is empty.
    //
    // # Parameters
    // - `set`: a set
    is_empty: set -> Bool;

    // Gets the number of elements in a set.
    //
    // # Parameters
    // - `set`: a set
    get_size: set -> I64;

    // Checks whether a set contains the specified element.
    //
    // # Parameters
    // - `elem`: a element
    // - `set`: a set
    contains: SetElem set -> set -> Bool;

    // Inserts an element into a set.
    //
    // # Parameters
    // - `elem`: a element
    // - `set`: a set
    insert: SetElem set -> set -> set;

    // Erases all elements which is equivalent to the specified element.
    //
    // # Parameters
    // - `elem`: a element
    // - `set`: a set
    erase: SetElem set -> set -> set;

    // Converts a set into an iterator.
    //
    // # Parameters
    // - `set`: a set
    to_iter: set -> SetIterator set;

    // Converts a set into an array.
    //
    // # Parameters
    // - `set`: a set
    to_array: set -> Array (SetElem set);

    //from_iter: [it: Iterator, Iterator::Item it = e, e = SetElem set] it -> set;
}

//---------------------------------------------------------------------------
//  SortedSet
//---------------------------------------------------------------------------

// The trait for sorted sets.
trait SortedSet = Set + SortedSetIF;

// The interface for sorted sets.
trait set: SortedSetIF {
    // Finds all elements in the specified range.
    //
    // # Parameters
    // - `lower_bound`: the lower bound of the range
    // - `upper_bound`: the upper bound of the range
    // - `ascending`: order of elements (true: ascending, false: descending)
    // - `set`: a set
    //
    // Example:
    // ```
    // set.select_range(included(5), excluded(10), true)    // finds all elements where 5 <= key < 10 in ascending order
    // set.select_range(excluded(5), included(10), false)   // finds all elements where 5 < key <= 10 in descending order
    // set.select_range(unbound(), excluded(10), true)    // finds all elements where key < 10 in ascending order
    // set.select_range(included(5), unbound(), true)    // finds all elements where 5 <= key in ascending order
    // set.select_range(unbound(), unbound(), true)    // finds all elements in ascending order
    // ```
    select_range: Bound (SetElem set) -> Bound (SetElem set) -> Bool -> set -> Set::SetIterator set;
}

//---------------------------------------------------------------------------
//  Map
//---------------------------------------------------------------------------

// The trait for abstract maps.
trait map: Map {
    // The type of the keys.
    type MapKey map;
    // The type of the values.
    type MapValue map;
    // The type of the iterator returned by `to_iter`.
    // `Item (MapIterator map)` should be equal to `(MapKey map, MapValue map)`.
    type MapIterator map;

    // Checks whether a map is empty.
    //
    // # Parameters
    // - `map`: a map
    is_empty: map -> Bool;

    // Gets the number of entries in a map.
    //
    // # Parameters
    // - `map`: a map
    get_size: map -> I64;

    // Checks whether any entry exists whose key is equivalent to the specified key.
    //
    // # Parameters
    // - `key`: a key
    // - `map`: a map
    contains_key: MapKey map -> map -> Bool;

    // Finds an entry whose key is equivalent to the specified key.
    // If an entry is found, returns `some(v)` where `v` is the value.
    // If no entry is found, returns `none()`.
    //
    // # Parameters
    // - `key`: a key
    // - `map`: a map
    find: MapKey map -> map -> Option (MapValue map);

    // Inserts an entry into a map.
    //
    // # Parameters
    // - `key_value`: a key-value pair
    // - `map`: a map
    insert: (MapKey map, MapValue map) -> map -> map;

    // Erases all entries whose key is equivalent to the specified key.
    //
    // # Parameters
    // - `key`: a key
    // - `map`: a map
    erase: MapKey map -> map -> map;

    // Inserts an entry to a map, or erases an entry from a map.
    //
    // Semantically, `map.set(key, opt_v)` is equivalent to
    // `match opt_v { some(v) => map.insert(key, v), none() => map.erase(key) }`.
    //
    // # Parameters
    // - `key`: A key
    // - `opt_value`: If `some(v)`, an element is inserted. if `none()`, any element for `key` is erased.
    // - `map`: A map
    set: MapKey map -> (Option (MapValue map)) -> map -> map;

    // Modifies a map by a functorial action.
    //
    // Semantically, `map.act(key, fun)` is equivalent to
    // `fun(map.find(key)).Functor::map(|opt_v| map.set(key, opt_v))`.
    //
    // `action` is a function which takes an `Option v` as an argument and returns an `f (Option v)`,
    //  where `v` is equal to `MapValue map`.
    //  The argument of `action` is `some(old_value)` if there is an entry for the specified key, `none()` if there is no entry.
    //  `action` should return a lifted value for `f` of `some(new_value)`
    //   if you want to keep the entry (with or without changing the value),
    //   or return a lifted value for `f` of `none()` if you want to remove the entry.
    //
    // # Parameters
    // - `key`: A key
    // - `action`: The functorial action to be performed on the value for the key `key`.
    // - `map`: A map
    act: [f: Functor] MapKey map -> (Option (MapValue map) -> f (Option (MapValue map))) -> map -> f map;

    // Converts a map into an iterator of entries.
    //
    // # Parameters
    // - `map`: a map
    to_iter: map -> Map::MapIterator map;

    // Converts a map into an array of entries.
    //
    // # Parameters
    // - `map`: a map
    to_array: map -> Array (MapKey map, MapValue map);

    //from_iter: [it: Iterator, Iterator::Item it = (k, v), MapKey map = k, MapValue map = v] it -> map;
}

namespace Map {
    namespace Default {
        // Default implementation of `Map::set`.
        default_set: [map: Map] MapKey map -> (Option (MapValue map)) -> map -> map;
        default_set = |key, opt_v, map| match opt_v { some(v) => map.insert((key, v)), none() => map.erase(key) };

        // Default implementation of `Map::act`.
        default_act: [f: Functor, map: Map] MapKey map -> (Option (MapValue map) -> f (Option (MapValue map))) -> map -> f map;
        default_act = |key, fun, map| fun(map.find(key)).Functor::map(|opt_v| map.set(key, opt_v));
    }
}

//---------------------------------------------------------------------------
//  SortedMap
//---------------------------------------------------------------------------

// The trait for sorted maps.
trait SortedMap = Map + SortedMapIF;

// The interface for sorted maps.
trait map: SortedMapIF {
    // Finds all entries in the specified range.
    //
    // # Parameters
    // - `lower_bound`: the lower bound of the range
    // - `upper_bound`: the upper bound of the range
    // - `ascending`: order of entries (true: ascending, false: descending)
    // - `map`: a map
    //
    // Example:
    // ```
    // map.select_range(included(5), excluded(10), true)    // finds all entries where 5 <= key < 10 in ascending order
    // map.select_range(excluded(5), included(10), false)   // finds all entries where 5 < key <= 10 in descending order
    // map.select_range(unbound(), excluded(10), true)    // finds all entries where key < 10 in ascending order
    // map.select_range(included(5), unbound(), true)    // finds all entries where 5 <= key in ascending order
    // map.select_range(unbound(), unbound(), true)    // finds all entries in ascending order
    // ```
    select_range: Bound (MapKey map) -> Bound (MapKey map) -> Bool -> map -> Map::MapIterator map;
}

//---------------------------------------------------------------------------
//  Bound
//---------------------------------------------------------------------------

// A bound of a range, used in `SortedMap` and `SortedSet`.
type Bound a = unbox union {
    // The bound is included
    included: a,
    // The bound is excluded
    excluded: a,
    // Unbound
    unbound: ()
};

impl Bound: Functor {
    map = |f, bound| match bound {
        included(a) => included(f(a)),
        excluded(a) => excluded(f(a)),
        unbound() => unbound(),
    };
}

impl [a: ToString] Bound a: ToString {
    to_string = |bound| match bound {
        included(a) => "included(" + a.to_string + ")",
        excluded(a) => "excluded(" + a.to_string + ")",
        unbound() => "unbound()",
    };
}

//---------------------------------------------------------------------------
//  KeyCompare
//---------------------------------------------------------------------------

// The trait of key comparators.
trait kc : KeyCompare {
    // The type of keys.
    type Key kc;

    // An empty key comparator.
    empty: kc;
    // Returns false if and only if the first key should appear after the second key.
    compare : Key kc -> Key kc -> kc -> Bool;
}

namespace KeyCompare {
    // Checks if the key is above the lower bound.
    //
    // # Parameters
    // - `lower_bound`: a lower bound.
    // - `key`: a key.
    // - `kc`: a key comparator.
    above_lower_bound: [kc: KeyCompare, Key kc = k] Bound k -> k -> kc -> Bool;
    above_lower_bound = |lower_bound, key, kc| (
        match lower_bound {
            unbound() =>  true,
            included(bound) => !kc.compare(key, bound),
            excluded(bound) => kc.compare(bound, key),
        }
    );

    // Checks if the key is below the uppwer bound.
    //
    // # Parameters
    // - `upper_bound`: a upper bound.
    // - `key`: a key.
    // - `kc`: a key comparator.
    below_upper_bound: [kc: KeyCompare, Key kc = k] Bound k -> k -> kc -> Bool;
    below_upper_bound = |upper_bound, key, kc| (
        match upper_bound {
            unbound() => true,
            included(bound) => !kc.compare(bound, key),
            excluded(bound) => kc.compare(key, bound),
        }
    );
}

// The type of key comparators which compares keys with `LessThan::less_than`.
type KeyLessThan k = unbox struct {};

impl [k: LessThan] KeyLessThan k: KeyCompare {
    type Key (KeyLessThan k) = k;
    empty = KeyLessThan {};
    compare = |x, y, kc| x < y;
}

// The type of key comparators which compares keys with `LessThan::less_than` in reversed order.
type KeyGreaterThan k = unbox struct {};

impl [k: LessThan] KeyGreaterThan k: KeyCompare {
    type Key (KeyGreaterThan k) = k;
    empty = KeyGreaterThan {};
    compare = |x, y, kc| y < x;
}

// The type of key comparators which uses a function.
//
// The implementation of this type for `KeyCompare::empty` is a dummy; do not use it.
type KeyCompareWithFunc k = unbox struct {
    compare: k -> k -> Bool
};

namespace KeyCompareWithFunc {
    // Creates a key comparator using the specified function.
    //
    // # Parameters
    // - `compare`: a comparator function
    make: (k -> k -> Bool) -> KeyCompareWithFunc k;
    make = |compare| KeyCompareWithFunc {
        compare: compare
    };
}

impl KeyCompareWithFunc k: KeyCompare {
    type Key (KeyCompareWithFunc k) = k;
    empty = KeyCompareWithFunc { 
        compare: |_, _| false      // dummy; do not use
    };
    compare = |x, y, kc| (kc.@compare)(x, y);
}

